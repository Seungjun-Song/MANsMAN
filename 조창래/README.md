# 20240227 TIL
## 예시: 사용자에게 영화 추천하기
 $N$명의 유저들이 있고, $M$개의 영화들이 있다.  각 유저는 각 영화에 '좋아요' 버튼을 클릭할 수 있다.

## Naive method
유저에게 영화를 추천할 수 있는 가장 간단한 방법은, 가장 많은 '좋아요' 버튼을 받은 영화를 추천하는 것이다. 각 영화가 받은 '좋아요' 버튼의 개수를 세고, 그것의 개수가 많은 순서대로 영화를 나열한다. 그 순서대로 영화를 추천하면 된다.

### 단점
모든 유저가 같은 영화를 추천받는다. 각 유저의 기호를 반영한 추천 시스템을 생각해보자.

## Cosine similarity
$M$차원 벡터 $v_{1,} \ v_2$ 가 주어졌을 때, 두 벡터의 '방향'의 유사성을 판단하고 싶다. 이를 위해 두 벡터 사이의 '각도'의 cosine값을 사용한다:
$$ \cos \theta = \frac{v_{1}\cdot v_{2}}{|v_{1}||v_2| } $$
이는 항상 -1에서 1사이의 값을 지닌다. 

## User-based collborative filtering
$N \times M$ 행렬 $A$를 생각하자. $i(1 \leq i \leq N)$번째 유저가 $j(1 \leq j \leq M)$번째 영화에 '좋아요' 버튼을 클릭했을 때, $A_{ij} = 1$로 두고, 그렇지 않은 경우에는 $A_{ij} = 0$으로 둔다.
첫 번째 유저가 시청하지 않은 영화 중에서, 적합한 영화를 추천하고 싶다. 유저들의 기호 사이의 유사성을 계산해서 영화를 추천해보자.

1. 첫 번째 유저와 다른 모든 유저들 사이의 '유사성'을 cosine similarity를 이용해서 계산한다: 예를 들어, 첫 번째 유저와 두 번째 유저 사이의 '유사성'은 A의 첫 번째 행과 두 번째 행 사이의 cosine similarity이다.
2. cosine similarity들을 높은 순서대로 나열한다: 단, cosine similarity가 0인 경우는 제외한다.
3. 첫 번째 유저가 시청하지 않은 영화들에 대해, 그 영화에 '좋아요' 버튼을 클릭한 유저와의 cosine similarity를 더한다. 그 결과값들을 높은 순서대로 나열하고, 그 순서대로 영화들을 추천한다.

# 20240228 TIL
## Item-based collborative filtering
유저들 사이의 유사성이 아닌, 영화들 사이의 유사성을 계산해서 영화를 추천하고 싶다.
$M \times N$ 행렬 $B$를 생각하자. $i(1 \leq i \leq M)$번째 영화에 대해 $j (1 \leq j \leq N)$번째 유저가 '좋아요' 버튼을 클릭했다면, $B_{ij} = 1$로 두고, 그렇지 않은 경우에는 $B_{ij} = 0$으로 둔다.
첫 번째 유저가 시청하지 않은 영화 중에서, 적합한 영화를 추천하고 싶다.

1. 첫 번째 유저가 시청한 모든 영화들에 대해, 그 영화와 다른 영화들 사이의 유사성을 cosine similarity를 이용해서 계산한다.
2. 첫 번째 유저가 시청하지 않은 모든 영화들에 대해, 그 영화와 시청된 영화 사이의 cosine similarity들을 모두 더한다.
3. 2에서의 결과값들을 높은 순서대로 나열하고, 그 순서대로 영화들을 추천한다.

# 20240229 TIL 
## Matrix Factorization
#### 예시의 일반화 
이전 예시에서는 유저가 영화에 '좋아요' 버튼을 누를 수 있는 경우를 생각했다. 이번에는 유저가 영화에 평점을 매길 수 있다고 가정하자. 

$N$명의 유저와 $M$명의 영화가 있다고 가정하자. $N \times M$ 유저 - 평점 행렬 $A$를 생각하자. $i$번째 유저가 $j$번째 영화에 $a_{ij}$점의 점수를 매겼다면 $A_{ij} = a_{ij}$가 된다. 만약 $i$번째 유저가 $j$번째 영화에 점수를 매기지 않았다면, $A_{ij} = null$이 된다.   

이때 유저가 시청하지 않은 영화에 대해, 유저의 그 영화의 평점을 예측하고 싶다: 달리 말하면, $A_{ij} = null$일 때 $A_{ij}$를 추정하고 싶다.

#### 아이디어
적절한 유저의 feature를 $d$개 선택한다. 그것들을 이용해 유저를 $R^d$의 벡터로 나타낸다.
적절한 영화의 feature를 $d$개 선택한다. 그것들을 이용해 영화를 $R^d$의 벡터로 나타낸다.
이때 유저들의 $N \times d$ 행렬 $U$와, 영화들의 $M \times d$ 행렬 $V$를 생각하자. 이때 $U \times V^T$를 $A$에 근사할 수 있다면, $A_{ij}$는 $(U \times V^T)_{ij}$로 추정할 수 있다. 따라서 기존의 문제는, 적절한 $U$와 $V$를 찾는 문제로 귀결된다.

적절한 Loss function을 최소화하는 방식을 사용하면, SGD를 사용할 수 있다.
